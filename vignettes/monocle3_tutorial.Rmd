---
title: "Tutorial: countsplitting and Monocle3" 
output: rmarkdown::html_vignette
bibliography: latent.bib
vignette: >
  %\VignetteIndexEntry{"Monocle3 Tutorial: countsplitting and Monocle3"}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning=FALSE)
```

Before using this tutorial, we recommend that you read through our ``introduction to count splitting" tutorial to understand our method in a simple package with simulated data. 

For this tutorial, we reproduce the Monocle3 [vignette](https://cole-trapnell-lab.github.io/monocle3/docs/trajectories/), but we apply count splitting. The takeaway is that, on this data with a true trajectory and true signal, count splitting does not really change the conclusions. 

# Install Monocle3

If you don't already have `Monocle3`, you will need to install it. Please visit [this link](https://cole-trapnell-lab.github.io/monocle3/docs/installation/) for installation details. As `Monocle3` is in Beta, there may be some trouble shooting involved. 

Next, you should load the package, along with others that we will use in this tutorial.

```{r, message=FALSE, warning=FALSE}
library(monocle3)
library(tidyverse)
library(countsplit)
```

# Load the data

We do this in the same way as in the Monocle3 tutorial. The key step is constructing the object.

```{r}
expression_matrix <- readRDS(url("https://depts.washington.edu:/trapnell-lab/software/monocle3/celegans/data/packer_embryo_expression.rds"))
cell_metadata <- readRDS(url("https://depts.washington.edu:/trapnell-lab/software/monocle3/celegans/data/packer_embryo_colData.rds"))
gene_annotation <- readRDS(url("https://depts.washington.edu:/trapnell-lab/software/monocle3/celegans/data/packer_embryo_rowData.rds"))
```

But we now want to do count splitting! We do this on the expression matrix only. We take the transpose just to be consistent with out paper, where we want to have cells in the rows and genes in the columns.

```{r}
epsilon=0.5
set.seed(1)
Xtrain <-apply(expression_matrix,2,function(u) rbinom(n=length(u), size=u, p=epsilon))
Xtest <- expression_matrix-Xtrain
cds_train <- new_cell_data_set(Xtrain,
                         cell_metadata = cell_metadata,
                         gene_metadata = gene_annotation)
```

Now we want to follow the preprocessing and pseudotime steps from the Monocle3 tutorial to come up with pseudotime estiamtes.


Ok! Preprocessing! Using the same steps as the tutorial. 

```{r}
cds_train <- preprocess_cds(cds_train, num_dim = 50)
cds_train <- align_cds(cds_train, alignment_group = "batch", residual_model_formula_str = "~ bg.300.loading + bg.400.loading + bg.500.1.loading + bg.500.2.loading + bg.r17.loading + bg.b01.loading + bg.b02.loading")
```

We see that in few dimensions, the cells cluster really nice by their true differentiation day. So we know that we are doing something reasonable even though we only used the training set. 

```{r}
cds_train <- reduce_dimension(cds_train)
plot_cells(cds_train, label_groups_by_cluster=FALSE,  color_cells_by = "cell.type")
```

The one difference we are using is that we are saying NO partition. Because we want one single branch for simplicity in our regression analysis. Sorry lol. 

```{r}
cds_train <- cluster_cells(cds_train)
cds_train <- learn_graph(cds_train, use_partition=F)
plot_cells(cds_train,
           color_cells_by = "cell.type",
           label_groups_by_cluster=FALSE,
           label_leaves=FALSE,
           label_branch_points=FALSE)
```

We are required to specify a starting cell. Since we know that we want the starting point of pseudotime to be on day0, we will use a day0 cell as the start. 

```{r}
get_earliest_principal_node <- function(cds, time_bin="130-170"){
  cell_ids <- which(colData(cds)[, "embryo.time.bin"] == time_bin)
  
  closest_vertex <-
  cds@principal_graph_aux[["UMAP"]]$pr_graph_cell_proj_closest_vertex
  closest_vertex <- as.matrix(closest_vertex[colnames(cds), ])
  root_pr_nodes <-
  igraph::V(principal_graph(cds)[["UMAP"]])$name[as.numeric(names
  (which.max(table(closest_vertex[cell_ids,]))))]
  
  root_pr_nodes
}
cds_train <- order_cells(cds_train, root_pr_nodes=get_earliest_principal_node(cds_train))
plot_cells(cds_train,
           color_cells_by = "pseudotime",
           label_cell_groups=FALSE,
           label_leaves=FALSE,
           label_branch_points=FALSE,
           graph_label_size=1.5)
```


Now we are going to use Monocle3 to study differential expression along pseudotime! Using the same steps as in their tutorial! But the difference is that we will use the TEST set for fitting the models.

```{r}
cds_test <- new_cell_data_set(Xtest,
    gene_metadata = gene_annotation,
    cell_metadata=colData(cds_train)
)
```

We need to add the training set pseudotime to the cds_test metadata.

```{r}
colData(cds_test)$pseudotime_train <- pseudotime(cds_train)
```


We now skip to the section "finding genes that change as a function of pseudotime". 

To save some time, let's only use a random subset of genes. Maybe actually we should pick high var genes?
```{r}
ciliated_genes <- c("che-1",
                    "hlh-17",
                    "nhr-6",
                    "dmd-6",
                    "ceh-36",
                    "ham-1")
cds_test_subset <- cds_test[rowData(cds_test)$gene_short_name %in% ciliated_genes,]
gene_fits <- fit_models(cds_test_subset, model_formula_str = "~pseudotime_train+ batch",
                        expression_family="negbinomial")

coefficient_table(gene_fits) %>% filter(term == "pseudotime_train") %>% 
         select(gene_short_name, term, q_value, estimate)
```

The p-values are literally so tiny-- even with count splitting. Huh. 

# Graph Test

This is gonna be harder but its important. 

```{r}
cds_mix <- cds_train
counts(cds_mix) <- Xtest
ciliated_cds_pr_test_res <- graph_test(cds_mix, neighbor_graph="principal_graph", cores=4)
pr_deg_ids <- row.names(subset(ciliated_cds_pr_test_res, q_value < 0.0005))
```

Here are a couple of interesting genes that score as highly significant according to graph_test():

```{r,results='hide'}
plot_cells(cds_mix, genes=c("hlh-4", "gcy-8", "dac-1", "oig-8"),
           show_trajectory_graph=FALSE,
           label_cell_groups=FALSE,
           label_leaves=FALSE)
```




HOPEFULLY we will see that the first gene is activated before the others. That would be great. If its not something is messed up. 
Ok great its the same story, the only wierd thing is this REALLY big value of pseudotime that happened along one of our choices. Whoops! Will fix someday. 

```{r}
AFD_genes <- c("gcy-8", "dac-1", "oig-8")
AFD_lineage_cds <- cds_mix[rowData(cds_mix)$gene_short_name %in% AFD_genes,
                       colData(cds_mix)$cell.type %in% c("AFD")]
plot_genes_in_pseudotime(AFD_lineage_cds,
                         color_cells_by="embryo.time.bin",
                         min_expr=0.5)
```