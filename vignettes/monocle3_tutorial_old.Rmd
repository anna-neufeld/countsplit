---
title: "Tutorial: countsplitting and Monocle3 OLD" 
output: rmarkdown::html_vignette
bibliography: latent.bib
vignette: >
  %\VignetteIndexEntry{"Monocle3 Tutorial: OLD"}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning=FALSE)
```

Before using this tutorial, we recommend that you read through our ``introduction to count splitting" tutorial to understand our method in a simple package with simulated data. 

As in the ``scran`` tutorial, we use a real dataset from @elorbany2022single that is also used in our paper. The dataset contains 10,000 cells collected over 15 days of a directed differentiation protocol from induced pluripotent stem cells (IPSC) to cardiomyocytes (cm). 

We carry out an analysis pipeline inspired by the Monocle3 [tutorial](https://cole-trapnell-lab.github.io/monocle3/docs/trajectories/), and we note that the analysis is similar to (but not idental to) the pipeline used in our paper. 

<!-- # Install Monocle3 -->

<!-- If you don't already have ``Monocle3``, you will need to install it. As it is in Beta, you should install it from github. Details are available at the Monocle3 [website](https://cole-trapnell-lab.github.io/monocle3/docs/installation/).  -->

<!-- Next, you should load the package, along with others that we will use in this tutorial. -->

<!-- ```{r, message=FALSE, warning=FALSE} -->
<!-- library(monocle3) -->
<!-- library(scran) -->
<!-- library(tidyverse) -->
<!-- library(countsplit) -->
<!-- ``` -->

<!-- # Preparing the data using Monocle3 -->

<!-- This data is included in this package as a ``SingleCellExperiment`` object, which is compatible with the ``scran`` package. Now that we are working with ``Monocle3``, we add a few steps to convert the data to the correct datatype. Note, however, that count splitting can occur prior to this step. -->

<!-- ```{r} -->
<!-- data(cm) -->
<!-- epsilon=0.5 -->
<!-- set.seed(1) -->
<!-- X <- t(counts(cm)) -->
<!-- Xtrain <-apply(X,2,function(u) rbinom(n=length(u), size=u, p=epsilon)) -->
<!-- rownames(Xtrain) <- rownames(X) -->
<!-- colnames(Xtrain) <- colnames(X) -->
<!-- Xtest <- X-Xtrain -->
<!-- rownames(Xtest) <- rownames(X) -->
<!-- colnames(Xtest) <- colnames(X) -->
<!-- ```` -->

<!-- Now we want to follow the preprocessing and pseudotime steps from the Monocle3 tutorial to come up with pseudotime estiamtes. -->
<!-- We want to do all of these on the training set. So we need to make a Monocle3 object! Note that the gene metadata is required!!! -->


<!-- ```{r} -->
<!-- gene_meta <- data.frame(gene_short_name = rownames(t(Xtrain))) -->
<!-- cell_meta <- colData(cm) -->
<!-- rownames(gene_meta) <- rownames(t(X)) -->
<!-- cds_train <- new_cell_data_set(t(Xtrain), -->
<!--     gene_metadata = gene_meta, -->
<!--     cell_metadata=cell_meta -->
<!-- ) -->
<!-- ``` -->

<!-- Ok! Preprocessing! We use individual as the alignmment group and we also regress out percent.mito. We could decide to regress out any metadata that we choose! -->
<!-- ```{r} -->
<!-- cds_train <- preprocess_cds(cds_train, num_dim = 50) -->
<!-- cds_train <- align_cds(cds_train, alignment_group = "individual", residual_model_formula_str = "~ percent.mito") -->
<!-- ``` -->

<!-- We see that in few dimensions, the cells cluster really nice by their true differentiation day. So we know that we are doing something reasonable even though we only used the training set.  -->

<!-- ```{r} -->
<!-- cds_train <- reduce_dimension(cds_train) -->
<!-- plot_cells(cds_train, label_groups_by_cluster=FALSE,  color_cells_by = "diffday") -->
<!-- ``` -->

<!-- Clustering the cells is a required step of the Monocle3 pipeline, so we use that here. In the paper, we really just wanted one branch. Here we will see what Monocle does my default! -->
<!-- The one difference from the tutorial is that I would like to use  -->

<!-- ```{r} -->
<!-- cds_train <- cluster_cells(cds_train) -->
<!-- cds_train <- learn_graph(cds_train, partition='F') -->
<!-- plot_cells(cds_train, color_cells_by = "diffday", -->
<!--            label_groups_by_cluster=FALSE, -->
<!--            label_leaves=FALSE, -->
<!--            label_branch_points=FALSE) -->
<!-- ``` -->

<!-- We are required to specify a starting cell. Since we know that we want the starting point of pseudotime to be on day0, we will use a day0 cell as the start.  -->
<!-- ```{r} -->
<!-- get_earliest_principal_node <- function(cds, time_bin="day0"){ -->
<!--   cell_ids <- which(colData(cds)[, "diffday"] == time_bin) -->

<!--   closest_vertex <- -->
<!--   cds@principal_graph_aux[["UMAP"]]$pr_graph_cell_proj_closest_vertex -->
<!--   closest_vertex <- as.matrix(closest_vertex[colnames(cds), ]) -->
<!--   root_pr_nodes <- -->
<!--   igraph::V(principal_graph(cds)[["UMAP"]])$name[as.numeric(names -->
<!--   (which.max(table(closest_vertex[cell_ids,]))))] -->

<!--   root_pr_nodes -->
<!-- } -->
<!-- cds_train <- order_cells(cds_train, root_pr_nodes=get_earliest_principal_node(cds_train)) -->
<!-- ``` -->


<!-- Now we are going to use Monocle3 to study differential expression along pseudotime! Using the same steps as in their tutorial! But the difference is that we will use the TEST set for fitting the models. -->

<!-- ```{r} -->
<!-- cds_test <- new_cell_data_set(t(Xtest), -->
<!--     gene_metadata = gene_meta, -->
<!--     cell_metadata=colData(cm_train) -->
<!-- ) -->
<!-- ``` -->

<!-- We need to add the training set pseudotime to the cds_test metadata. -->

<!-- ```{r} -->
<!-- colData(cds_test)$pseudotime_train <- pseudotime(cds_train) -->
<!-- ``` -->

<!-- To save some time, let's only use a random subset of genes. Maybe actually we should pick high var genes? -->
<!-- ```{r} -->
<!-- cds_test_subset <- cds_test[1:500,] -->
<!-- gene_fits <- fit_models(cds_test_subset, model_formula_str = "~pseudotime_train") -->

<!-- coefficient_table(gene_fits) %>% filter(term == "~pseudotime_train") %>% filter (q_value < 0.05) %>% -->
<!--          select(gene_short_name, term, q_value, estimate) -->
<!-- ``` -->


<!-- The table above shows the genes that we identified as differentially expressed! -->

<!-- We encourage interested readers to go check out even more options in the Monocle3 tutorials, which are very well written!  -->


<!-- ### Graph test -->

<!-- This one is harder! But we can still redo the tutorial. We just need to be smart.  -->