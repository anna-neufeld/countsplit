---
title: "Tutorial: using ``countsplit`` to perform differential expression analysis on single cell RNA-seq data. 
output: rmarkdown::html_vignette
bibliography: latent.bib
vignette: >
  %\VignetteIndexEntry{countsplit_tutorial}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE
)
```

In this tutorial, we demonstrate how to use the ``countsplit`` package to perform inference after latent variable selection for scRNA-seq data. In the first part of this tutorial, we work with simple simulated data and use only the ``countsplit`` package. In the second half of this tutorial, we show how the ``countsplit`` package can be integrated into pipelines with other scRNA-seq packages such as ``monocle3`` and ``seurat``. 

We start by loading the packages we will be working with. Make sure that ``remotes`` is installed by running ``install.packages("remotes")``, then type

```{r,eval=FALSE}
remotes::install_github("anna-neufeld/countsplit")
install.packages("speedglm")
```

Next, load the following packages. Note that ``speedglm`` is optional but will probably be a good idea for large scRNA-seq datasets. 

```{r, message=FALSE}
library(countsplit)
library(speedglm)
```

# Simple example on simulated data

To get comfortable with the ``countsplit`` package, we start by working with a simple simulated dataset.

Suppose that we have $n=1000$ cells and $p=200$ genes. Suppose that every count $\bold{X}_{ij}$ is drawn from a $\text{Poisson}(5)$ distribution. We first generate this data. 

```{r}
set.seed(1)
n <- 1000
p <- 200
X <- matrix(rpois(n*p, lambda=5), nrow=n)
```

Applying count splitting to this data is straightforward. 

```{r}

```

Suppose we are interested in studying differential expression across two clusters, obtained with k-means clustering. First we can see that the Naive method does not control the Type 1 error rate. Here is an example of the naive method: 

```{r}
set.seed(3)
clusters.full <- kmeans(log(X+1), centers=2)$cluster
results.naive <- fit_glms(X, clusters.full, family="poisson")
head(results.naive)
```

We can make a uniform QQ-plot of the p-values for the naive method to see that they don't control the Type 1 error.

```{r}
library(ggplot2)
ggplot(data=results.naive, aes(sample=pval))+geom_qq(distribution="qunif")+geom_abline(col="red")
```

Next we fix the problem by using count splitting. 

```{r}
set.seed(2)
split <- countsplit(X, epsilon=0.5)
Xtrain <- split$train
Xtest <- split$test
clusters.train <- kmeans(log(Xtrain+1), centers=2)$cluster
results.countsplit <- fit_glms(Xtest, clusters.train, family="poisson")
ggplot(data=results.countsplit, aes(sample=pval))+geom_qq(distribution="qunif")+geom_abline(col="red")
```

Yay.

# Example integrated with Seurat

The example above is really everything that you need to know about the ``countsplit`` package. But integrating it with existing pipelines can be kind of hard. Here we try to go through a few illustrative examples to get you to see the logic. We do everything on the cardiomyocite data used in our paper. It is included in the data section of the R package.

```{r}
data(cm)
```

# Example integrated with Monocle3




# Example integrated with 